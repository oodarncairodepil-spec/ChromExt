// WhatsApp Web selectors and utilities for targeting chat elements

export interface WhatsAppChatElement {
  selector: string;
  description: string;
  element?: HTMLElement;
}

// Common selectors for WhatsApp Web chat elements
export const WHATSAPP_SELECTORS = {
  // Message input area selectors - Based on error1.txt structure
  MESSAGE_INPUT: [
    // Based on error1.txt - exact selectors for WhatsApp chat input
    'div[data-lexical-editor="true"][role="textbox"]',
    'div[contenteditable="true"][data-tab="10"][data-lexical-editor="true"]',
    '#main > footer > div.copyable-area > div > span > div > div._ak1r > div > div.lexical-rich-text-input > div[contenteditable="true"]',
    'div.x1hx0egp.x6ikm8r.x1odjw0f.x1k6rcq7.x6prxxf[contenteditable="true"]',
    'div[aria-placeholder="Type a message"][data-lexical-editor="true"]',
    // More specific fallback selectors - avoid matching attachment button
    'div[contenteditable="true"][data-tab="10"]:not(button):not([title="Attach"])',
    'div[role="textbox"]:not(button):not([title="Attach"])',
    '[aria-placeholder*="Type a message"]:not(button):not([title="Attach"])',
    '.selectable-text[contenteditable="true"]:not(button):not([title="Attach"])'
  ],
  
  // Chat container selectors
  CHAT_CONTAINER: [
    '[data-testid="conversation-panel-messages"]',
    '.message-list',
    '[role="log"]'
  ],
  
  // Active chat selectors
  ACTIVE_CHAT: [
    '[data-testid="chat-header"]',
    '.chat-header',
    '[data-testid="conversation-header"]'
  ],
  
  // Footer/input area container
  FOOTER_CONTAINER: [
    'footer[tabindex="-1"]',
    '[data-testid="compose-box-input"]',
    '.footer'
  ]
};

/**
 * Find WhatsApp chat input element using multiple selector strategies
 */
export function findChatInput(): HTMLElement | null {
  for (const selector of WHATSAPP_SELECTORS.MESSAGE_INPUT) {
    const element = document.querySelector(selector) as HTMLElement;
    if (element && element.isContentEditable) {
      return element;
    }
  }
  return null;
}

/**
 * Find element containing specific text (like "xghrtkl plzvy")
 */
export function findElementByText(searchText: string): {
  element: HTMLElement;
  selector: string;
  position: DOMRect;
} | null {
  const allElements = document.querySelectorAll('*');
  
  for (let i = 0; i < allElements.length; i++) {
    const element = allElements[i] as HTMLElement;
    if (element.textContent && element.textContent.includes(searchText)) {
      return {
        element,
        selector: generateSelector(element),
        position: element.getBoundingClientRect()
      };
    }
  }
  return null;
}

/**
 * Generate a CSS selector for an element
 */
function generateSelector(element: HTMLElement): string {
  if (element.id) {
    return `#${element.id}`;
  }
  
  if (element.className) {
    const classes = element.className.split(' ').filter(c => c.length > 0);
    if (classes.length > 0) {
      return `${element.tagName.toLowerCase()}.${classes.join('.')}`;
    }
  }
  
  // Fallback to tag name with position
  const parent = element.parentElement;
  if (parent) {
    const siblings = Array.from(parent.children);
    const index = siblings.indexOf(element);
    return `${parent.tagName.toLowerCase()} > ${element.tagName.toLowerCase()}:nth-child(${index + 1})`;
  }
  
  return element.tagName.toLowerCase();
}

/**
 * Send message to WhatsApp chat input
 */
export function sendMessageToChat(message: string): Promise<{success: boolean, error?: string}> {
  const chatInput = findChatInput();
  if (!chatInput) {
    console.error('Chat input not found');
    return Promise.resolve({ success: false, error: 'Chat input not found' });
  }
  
  try {
    // Focus the input first
    chatInput.focus();
    
    // Clear existing content using Lexical editor approach
    chatInput.innerHTML = '<p class="selectable-text copyable-text x15bjb6t x1n2onr6" dir="ltr" style="text-indent: 0px; margin-top: 0px; margin-bottom: 0px;"><br></p>';
    
    // Create the proper structure for WhatsApp Lexical editor
    const paragraph = chatInput.querySelector('p');
    if (paragraph) {
      paragraph.innerHTML = `<span class="selectable-text copyable-text xkrh14z" data-lexical-text="true">${message}</span>`;
    } else {
      // Fallback: create the structure from scratch
      chatInput.innerHTML = `<p class="selectable-text copyable-text x15bjb6t x1n2onr6" dir="ltr" style="text-indent: 0px; margin-top: 0px; margin-bottom: 0px;"><span class="selectable-text copyable-text xkrh14z" data-lexical-text="true">${message}</span></p>`;
    }
    
    // Trigger events specifically for Lexical editor
    const inputEvent = new InputEvent('input', {
      bubbles: true,
      cancelable: true,
      inputType: 'insertText',
      data: message
    });
    
    const compositionEndEvent = new CompositionEvent('compositionend', {
      bubbles: true,
      cancelable: true,
      data: message
    });
    
    // Dispatch events in the correct order for Lexical
    chatInput.dispatchEvent(inputEvent);
    chatInput.dispatchEvent(compositionEndEvent);
    chatInput.dispatchEvent(new Event('keyup', { bubbles: true }));
    chatInput.dispatchEvent(new Event('change', { bubbles: true }));
    
    // Keep focus
    chatInput.focus();
    
    // Find and click send button with multiple selectors
    const sendButtonSelectors = [
      '[data-testid="send"]',
      '[aria-label*="Send"]:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      '[aria-label*="send"]:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      'button[aria-label*="Send"]:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      'span[data-testid="send"]',
      'button span[data-testid="send"]',
      '[data-icon="send"]',
      'button[data-icon="send"]',
      // Additional selectors based on WhatsApp Web structure
      '#main footer button[type="submit"]:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      '#main footer button[aria-label="Send"]',
      '#main footer div[role="button"]:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      'footer button[data-testid="send"]',
      'footer span[data-icon="send"]',
      'footer button:has([data-icon="send"])',
      // Generic footer button selectors
      '#main footer button:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      'footer .copyable-area button:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      'footer button[tabindex="0"]:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      // XPath-based selectors converted to CSS
      '#main > footer button:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      '#main > footer div[role="button"]:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      // More specific selectors targeting send button next to chat input
      'div[contenteditable="true"] ~ div button[data-icon="send"]',
      'div[contenteditable="true"] ~ span button[data-icon="send"]',
      'div[role="textbox"] ~ div button[data-icon="send"]',
      'div[role="textbox"] ~ span button[data-icon="send"]',
      'div[data-lexical-editor="true"] ~ div button[data-icon="send"]',
      'div[data-lexical-editor="true"] ~ span button[data-icon="send"]',
      // Based on error2.txt structure - targeting elements near the chat input
      '#main > footer div.copyable-area ~ button:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      '#main > footer div.copyable-area + * button:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      '#main > footer span > div ~ button:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      '#main > footer span > div + * button:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      'div.lexical-rich-text-input ~ button:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      'div.lexical-rich-text-input + * button:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      'div._ak1r ~ button:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      'div._ak1r + * button:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      // Targeting buttons after file upload area but not the attach button itself
      'div[data-testid="media-attach-button"] ~ button:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      'div[data-testid="media-attach-button"] + * button:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      'button[data-testid="attach-button"] ~ button:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      'button[data-testid="attach-button"] + * button:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      // Generic footer button patterns - exclude attach and emoji buttons
      'footer > div > div > button:last-child:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      'footer > div > span > button:last-child:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      'footer button[type="button"]:last-of-type:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      'footer span[role="button"]:last-of-type:not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
      // Specific exclusion of plus-rounded and emoji icon buttons
      'footer button:not([data-icon="plus-rounded"]):not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])',
       'footer span:not([data-icon="plus-rounded"]):not([title="Attach"]):not([aria-haspopup="menu"]):not([data-icon="emoji"]):not([aria-label*="emoji"]):not([aria-label*="Emoji"])'
     ];
    
    // Debug: Log all footer buttons to understand the structure
    console.log('=== DEBUGGING SEND BUTTON SELECTION ===');
    const footerButtons = document.querySelectorAll('footer button, footer span[role="button"], footer div[role="button"]');
    console.log('Footer buttons found:', footerButtons.length);
    footerButtons.forEach((btn, index) => {
      console.log(`Button ${index}:`, {
        tagName: btn.tagName,
        className: btn.className,
        'data-testid': btn.getAttribute('data-testid'),
        'data-icon': btn.getAttribute('data-icon'),
        'aria-label': btn.getAttribute('aria-label'),
        'title': btn.getAttribute('title'),
        'role': btn.getAttribute('role'),
        'tabindex': btn.getAttribute('tabindex'),
        textContent: btn.textContent?.trim(),
        innerHTML: btn.innerHTML.substring(0, 100)
      });
    });
    
    let sendButton = null;
    let matchedSelector = '';
    for (const selector of sendButtonSelectors) {
      sendButton = document.querySelector(selector) as HTMLElement;
      if (sendButton) {
        matchedSelector = selector;
        console.log('Matched selector:', selector);
        console.log('Selected button details:', {
          tagName: sendButton.tagName,
          className: sendButton.className,
          'data-testid': sendButton.getAttribute('data-testid'),
          'data-icon': sendButton.getAttribute('data-icon'),
          'aria-label': sendButton.getAttribute('aria-label'),
          'title': sendButton.getAttribute('title'),
          textContent: sendButton.textContent?.trim()
        });
        break;
      }
    }
    
    if (sendButton) {
      // Additional check to ensure we're not clicking the attach or emoji button
      const isAttachButton = sendButton.getAttribute('title') === 'Attach' || 
                            sendButton.getAttribute('aria-haspopup') === 'menu' ||
                            sendButton.querySelector('[data-icon="plus-rounded"]');
      
      const isEmojiButton = sendButton.getAttribute('data-icon') === 'emoji' ||
                           sendButton.getAttribute('aria-label')?.toLowerCase().includes('emoji') ||
                           sendButton.querySelector('[data-icon="emoji"]');
      
      if (isAttachButton) {
        console.error('Found attach button instead of send button');
        return Promise.resolve({ success: false, error: 'Send button not found with any selector' });
      }
      
      if (isEmojiButton) {
        console.error('Found emoji button instead of send button');
        return Promise.resolve({ success: false, error: 'Found emoji button instead of send button' });
      }
      
      console.log('Clicking send button with selector:', matchedSelector);
      sendButton.click();
      
      // Wait a moment and check if the message was actually sent
      return new Promise((resolve) => {
        setTimeout(() => {
          const inputAfterSend = findChatInput();
          if (inputAfterSend && inputAfterSend.textContent && inputAfterSend.textContent.trim() !== '') {
            resolve({ success: false, error: 'Message was not sent - input still contains text' });
          } else {
            resolve({ success: true });
          }
        }, 500);
      });
    } else {
      console.error('Send button not found with any selector');
      return Promise.resolve({ success: false, error: 'Send button not found with any selector' });
    }
  } catch (error) {
    console.error('Error sending message:', error);
    return Promise.resolve({ success: false, error: 'Error sending message: ' + error });
  }
}